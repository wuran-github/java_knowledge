# 集合

<!-- TOC -->

- [集合](#集合)
    - [java集合框架](#java集合框架)
        - [将集合的接口与实现分离](#将集合的接口与实现分离)
        - [Collection接口](#collection接口)
        - [迭代器](#迭代器)
        - [泛型实用方法](#泛型实用方法)
        - [集合框架中的接口](#集合框架中的接口)
    - [具体的集合](#具体的集合)
        - [链表](#链表)
        - [数组列表](#数组列表)
        - [散列集](#散列集)
        - [树集](#树集)
        - [队列和双端队列](#队列和双端队列)
        - [优先队列](#优先队列)
    - [映射(Map)](#映射map)
        - [基本映射操作](#基本映射操作)
        - [更新映射项](#更新映射项)
        - [映射视图](#映射视图)
        - [弱散列集](#弱散列集)

<!-- /TOC -->

## java集合框架
- java最初版本只为常用的数据结构提供了很少的一组类：Vector Stack Hashtable BitSet与Enumeration接口。其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制。

### 将集合的接口与实现分离

- 与现代的数据结构类库的常见情况一样，Java集合类库也将接口与实现分离。也就是ADT(Abstract Data Type)

- 例如Queue接口，java中使用ArrayDeque类实现循环数组队列。用LinkedList类实现链表队列。


### Collection接口

- 在java类中，集合类的基本接口是Collection接口。这个接口有两个基本方法：
```
public interface Collection<E>
{
    boolean add(E element);
    Iterator<E> iterator();
}
```

- 除了这两个方法之外，还有几个方法。
- add用于添加元素，iterator用于返回一个实现Iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。(类似C#的IEnumerator)

### 迭代器

- Iterator接口包含4个方法：
```
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action)
}
```
- 通过反复调用next方法，可以逐个访问集合中的每个元素。如果到了末尾，next方法会抛出一个NoSuchElementException。下面是一个迭代的示例：
```
public static void iteratorTest(){
    List<Integer> ints = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        ints.add(i);
    }
    Iterator<Integer> iterator = ints.iterator();
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }
}
```
- 用foreach循环可以更加简练地表示同样的循环操作：
```
for(Integer i : ints){
    System.out.println(i);
}
```

- 编译器简单地将foreach循环翻译为带有迭代器的循环。(和C#一样)

- foreach循环可以与任何实现了Iterable接口的对象一起工作。(C#的IEnumerable)，接口只包含一个抽象方法：
```
public interface Iterable<E>
{
    Iterator<E> iterator();
}
```

- 在java 8中，甚至不用写循环，可以调用forEachReamining方法并提供要给lambda表达式。将对迭代器的每一个元素调用这个lambda方法，直到没有元素为止。
```
        iterator.forEachRemaining((i) -> System.out.println(i));

```

- 元素被访问的顺序取决于集合类型。如果ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而，如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预报元素被访问的次序。


- java集合类库中的迭代器与其他类库的迭代器在概念上有着重要区别。java的迭代器查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用next。查找时迭代器位置随之移动。

- 因此，应该将java迭代器认为是位于两个元素之间。当调用next时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用。

- Iterator的remove方法将会删除上次调用next方法时返回的元素。
- 在C#中实现IEnumerator很方便，因为有yield关键字。但是java中就比较麻烦，可以模仿C#的编译器实现，使用内部类创建。
  
- 如果在remove之前没有调用next是不合法的。如果这样做，将会抛出一个IllegalStateException异常。

### 泛型实用方法

- 由于Collection和Iterator都是泛型接口，可以编写操作任何集合类型的使用方法。例如：下面是一个检测任意集合是否包含指定元素的泛型方法：
```
public static <E> boolean contains(Collection<E> c, Object obj){
    for(E element: C){
        if(element.equals(obj)){
            return true;
        }
    }
    return false;
}
```
- 在C#中，contains方法不是静态方法，List中使用的是Array.IndexOf方法判断。

- java类库的设计者认为：这些实用方法非常有用，应该将他们提供给用户使用。这样，使用者就不必子集重新构建方法了。
- Collection接口声明了很多有用的方法，所有的实现类都必须提供这些方法，下面是一部分例子：
```
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
.... P367
```
- 类库提供了一个类AbstractCollection，他将基础方法size和iterator抽象化了，但是提供了其他方法的实例版本。所以我们可以通过继承该类免去编写一些例行方法。

- 创建一个Iterator比较麻烦，下面是模仿C#使用内部类实现的方法：
```
class StudentCollection extends AbstractCollection<Student> implements Collection<Student>{
    private Student[] students;
    private int capacity;
    private int num;
    public StudentCollection(){
        capacity = 100;
        num = 0;
        students = new Student[capacity];
    }

    @Override
    public Iterator<Student> iterator() {
        return new StudentIterator();
    }

    @Override
    public int size() {
        return num;
    }
    private class StudentIterator implements Iterator<Student>{
        private int currentNum;
        private Student current;
        public StudentIterator(){
            currentNum = -1;
            current = null;
        }
        @Override
        public boolean hasNext() {
           return StudentCollection.this.size() > currentNum+1;

        }

        @Override
        public Student next() {
            currentNum++;
            return StudentCollection.this.students[currentNum];
        }
    }
}
```

### 集合框架中的接口
- java集合框架为不同类型的集合定义了大量接口。

- 集合有两个基本接口：Collection和Map。Map是键值对。
- 以下是他们的不同：
```
作用    Map                     Collection
插入    put(k key, V value)     add(E element)
读取    get(K key)              迭代器
```

- List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：迭代器、整数索引。后一种方法称为随机访问，因为这样可以按任意顺序访问元素。

- 集合框架的这个方面设计的很不好。实际有两种有序集合，性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。与之不同，链表尽管也是有序的，但是随机访问很慢，最好使用迭代器来遍历。但是这两个都实现的是List接口。如果原先提供两个接口就会好一点。

- 标记接口RandomAccess可以用来测试一个特定的集合是否支持高效的随机访问。

- Set接口等同于Collection接口，不过其方法有更严谨的定义。Set(集)接口不允许增加重复的元素。要是是当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到想相同的散列码。

- SortedSet和SortedMap接口提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。

- java 6中定义了接口NavigableSet和NavigableMap，其中包含一些用于搜索和便利有序集和映射的方法。(本来应该直接包含在SortedSet和SortedMap接口中的)。TreeSet和TreeMap实现了这些接口。

--- 
## 具体的集合
- P380页展示了Java类库的具体集合。
    - ArrayList 动态增长和缩减的索引序列
    - LinkedList 一种可以在任何位置进行高效地插入和删除的有序序列
    - ArrayDeque 循环数组实现的双端队列
    - HashSet 没有重复元素的无序集合
    - TreeSet 有序集
    - EnumSet 包含枚举类型值的集
    - LinkedHashSet 记住元素插入次序的集
    - PriorityQueue 允许高效删除最小元素的集合
    - HashMap 存储键值对的数据结构
    - TreeMap 键值有序排列的映射表
    - EnumMap 键值属于枚举类型的映射表
    - LinkedHashMap 记住键值添加次序的映射表
    - WeakHashMap 值没用后可以被GC收回的映射表
    - IdentityHashMap 用==而不是Equals比较键值的映射表
  
### 链表
- 数据结构中的链表。java中的链表是双向链表。LinkedList

- 由于常常需要将元素添加到链表的中间，因此JAVA添加了一个新的接口ListIterator，包含add方法。
```
interface ListIterator<E> extends Iterator<E>
{
    void add(E element);
}
```
- 另外，ListIterator接口有两个方法，可以用来反向遍历链表。
```
E previous();
boolean hasPrevious()
```

- LinkedList的listIterator方法返回一个实现了ListTrerator接口的迭代器对象。

- add方法在迭代器位置之前添加一个新对象。

- remove方法则依赖于迭代器的当前状态。查看remove的源码：
```
public void remove() {
    if (lastRet < 0)
        throw new IllegalStateException();
    checkForComodification();

    try {
        AbstractList.this.remove(lastRet);
        if (lastRet < cursor)
            cursor--;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException e) {
        throw new ConcurrentModificationException();
    }
}
```
- 可以看到每次删除的时候会把lastRet置为-1，而lastRet小于0则不能remove，因此无法连续调用两次remove。
- lastRet是上一刻光标所在的位置，如ABCD，假设光标当前位置是C，previous的话光标会停在B，而lastRet指向C，即这时候remove会删除C。


- set方法用一个新元素取代调用next或previous方法返回的上一个元素。和remove一样，也是操作lastRet。

- 可以想象，如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，那这个迭代器就是无效的，并且不应该在使用。链表迭代器的设计使它能够检测到这种修改，而且会抛出一个异常。

- 为了避免发生并发修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

- 一个简单的检测并发修改的方式是集合跟踪改写操作的次数。同时每个迭代器维护一个独立的计数值，当检测到计数值和集合的改写操作计数值不一致时，抛出异常。

- 列表迭代器有两个返回索引的方法。nextIndex返回下一次调用next时返回元素的整数索引。previousIndex返回洗一次调用previous时返回元素的整数索引。

### 数组列表
- ArrayList实现了List接口。ArrayList封装了一个动态再分配的对象数组。

- Vector类也是一个数组列表，但是Vector的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果只有一个线程，代码在同步操作上就要耗费大量的时间。而ArrayList的方法不是同步的，因此不需要同步时使用ArrayList。

### 散列集
- java中，散列表用链表数组实现。每个列表被称为桶(bucket)。这是一种解决散列冲突的方法。详细可以看数据结构。
- 在java 8中，桶满时会从链表变成平衡二叉树。这样可以提高性能

- 如果想更多地控制散列表的运行性能，可以指定一个初始的桶数。桶数最好是素数。(还有再散列，装填因子等概念，在数据结构中有，这里不再复述)。
- 通常将桶数设置为预计元素个数的75%~150%。标准类库使用的桶数是2的幂，默认值为16.

- 散列表可以用于实现几个重要的数据结构，其中最简单的是set(集)。set是没有重复元素的集合。set的add方法首先在集中查找要添加的元素，当不存在时再添加进去。

- HashSet实现了基于散列表的集。这个集是无序的。

- 散列集迭代器将依次访问所有的桶。由于散列将元素分散在表的各个位置上，所以访问他们的顺序几乎是随机的。只有不关心集合中元素的顺序时才应该使用HashSet。
```
Set<String> strings = new HashSet<>();
for (int i = 10; i > 0; i--) {
    strings.add(i+"t");
}
for(String s : strings){
    System.out.println(s);
}
//输出乱序
4t
3t
2t
1t
10t
9t
8t
7t
6t
5t
```
- 上面的例子可以看出HashSet是无序的。

### 树集
- TreeSet与散列集十分类似，不过树集是有序的。可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地安好排序后的顺序呈现。
```
Set<String> strings = new TreeSet<>();
for (int i = 10; i > 0; i--) {
    strings.add(i+"t");
}
for(String s : strings){
    System.out.println(s);
}
//有序输出
10t
1t
2t
3t
4t
5t
6t
7t
8t
9t
```
- 正如类名所示，排序是用树结构完成的(当前用的时红黑树。)

- 要使用树集，必须能够比较元素。这些元素必须实现Comparable或者构造时提供一个Comparator。

- 有些不必排序的元素使用HashSet，因为有些元素无法比较大小。如矩形。
- 从java6开始，TreeSet实现了NavigableSet接口，这个接口增加了几个便于定位元素以及反向遍历的方法。

### 队列和双端队列

- 有两个端头的队列即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。

- 在java6中引入了Deque接口，并由ArrayDeque和LinkedList类实现。这两个都提供了双端队列，而且在必要时可以增加队列的长度。
- queue接口由LinkedList实现。
- peek对应First，poll对应Dequeue。add对应Enqueue。
```
private static void queueTest(){
    Queue<String> queue = new LinkedList<>();
    queue.add("t1");
    queue.add("t2");
    System.out.println(queue.peek());
    System.out.println(queue.poll());
    System.out.println(queue.poll());
}
//
t1
t1
t2
private static void dequeTest(){
    Deque<String> deque = new LinkedList<>();
    deque.addFirst("t1");
    deque.addFirst("t2");
    System.out.println(deque.peek());
}
//
t2
```

### 优先队列

- java中的优先队列用堆实现。具体看数据结构。

- 由于需要排序，因此优先队列也需要元素实现Comparable或提供Comparator比较器。

---
## 映射(Map)

- 映射(map)数据结构是键值对数据结构。映射用来存放键值对。

### 基本映射操作
- java类库为映射提供了两个通用的实现：HashMap和TreeMap。者两个类都实现了Map接口。

- HashMap对键进行散列，TreeMap用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。

- 两者的选择与集一样，散列稍微快一点，如果不需要排序就选择散列。
    - 如果map中没有与给定键的信息，get就会返回null。
    - 可以使用getOrDefault指定一个默认值返回。
    - 键是唯一的，不能对同一个键存放两个值，如果对同一个键两次调用put，第二次的值会取代第一次。
```
public static void hashMapTest(){
    Map<String, Integer> map = new HashMap<>();
    map.put("t1",1);
    map.put("t2",2);
    System.out.println(map.get("t1"));
    for(String key : map.keySet()){

    }
    for(Integer i : map.values()){

    }
    System.out.println(map.get("null"));//null
    System.out.println(map.getOrDefault("null",0));
}
//
1
null
0
```

### 更新映射项
- 处理映射时一个难点就是更新映射项。正常情况下，可以得到与一个键关联的原值，完成更新，再放回更新后的值。但是，必须考虑键第一次出现的情况。
- 如使用映射统计单词出现的频度。可以使用getOrDefault指定第一次出现时的值。
```
private static void updateMapTest(){
    Map<String,Integer> counts = new TreeMap<>();
    String[] words = {"word","hello","world","hello"};
    for(String word : words){
        counts.put(word,counts.getOrDefault(word,0)+1);
    }
    counts.forEach((k,v) -> System.out.println("word:"+k+", count:"+v));
}
```

- 另一种方法时首先调用putIfAbsent方法，只有当键原先存在时才会放入一个值。

- 更优雅的方法是使用merge。如果键原先不存在，下面的调用将把word与1关联，否则使用Integer:sum函数组合原值和1。
```
    private static void updateMapTest(){
        Map<String,Integer> counts = new TreeMap<>();
        String[] words = {"word","hello","world","hello"};
        for(String word : words){
            counts.merge(word,1,(n1,n2) -> n1+n2);
            //counts.merge(word,1,Integer::sum);
        }
        counts.forEach((k,v) -> System.out.println("word:"+k+", count:"+v));
    }
```

### 映射视图
- 集合框架不认为映射本身是一个集合。不过，可以得到映射的视图。这是实现了Collection接口或某个子接口的对象。
  
- 有3种视图：键值、值集合以及键值对集。键和键值对可以构成一个集合。因为映射中一个键只能由一个副本。下面的方法分别返回这3个视图。
```
Set<K> keySet()
Collection<V> values()
Set<Map.Entry<K,V>> entrySet()
```

- 需要说明的是，keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。(是一个内部类)

- 如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与他关联的值。不过，不能向键集视图增加元素。条目集视图有同样的限制。add方法会抛出异常。

### 弱散列集
- P394
