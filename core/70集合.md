# 集合

<!-- TOC -->

- [集合](#集合)
    - [java集合框架](#java集合框架)
        - [将集合的接口与实现分离](#将集合的接口与实现分离)
        - [Collection接口](#collection接口)
        - [迭代器](#迭代器)
        - [泛型实用方法](#泛型实用方法)
        - [集合框架中的接口](#集合框架中的接口)
    - [具体的集合](#具体的集合)
        - [链表](#链表)
        - [数组列表](#数组列表)
        - [散列集](#散列集)

<!-- /TOC -->

## java集合框架
- java最初版本只为常用的数据结构提供了很少的一组类：Vector Stack Hashtable BitSet与Enumeration接口。其中Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制。

### 将集合的接口与实现分离

- 与现代的数据结构类库的常见情况一样，Java集合类库也将接口与实现分离。也就是ADT(Abstract Data Type)

- 例如Queue接口，java中使用ArrayDeque类实现循环数组队列。用LinkedList类实现链表队列。


### Collection接口

- 在java类中，集合类的基本接口是Collection接口。这个接口有两个基本方法：
```
public interface Collection<E>
{
    boolean add(E element);
    Iterator<E> iterator();
}
```

- 除了这两个方法之外，还有几个方法。
- add用于添加元素，iterator用于返回一个实现Iterator接口的对象。可以使用这个迭代器对象依次访问集合中的元素。(类似C#的IEnumerator)

### 迭代器

- Iterator接口包含4个方法：
```
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action)
}
```
- 通过反复调用next方法，可以逐个访问集合中的每个元素。如果到了末尾，next方法会抛出一个NoSuchElementException。下面是一个迭代的示例：
```
public static void iteratorTest(){
    List<Integer> ints = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        ints.add(i);
    }
    Iterator<Integer> iterator = ints.iterator();
    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }
}
```
- 用foreach循环可以更加简练地表示同样的循环操作：
```
for(Integer i : ints){
    System.out.println(i);
}
```

- 编译器简单地将foreach循环翻译为带有迭代器的循环。(和C#一样)

- foreach循环可以与任何实现了Iterable接口的对象一起工作。(C#的IEnumerable)，接口只包含一个抽象方法：
```
public interface Iterable<E>
{
    Iterator<E> iterator();
}
```

- 在java 8中，甚至不用写循环，可以调用forEachReamining方法并提供要给lambda表达式。将对迭代器的每一个元素调用这个lambda方法，直到没有元素为止。
```
        iterator.forEachRemaining((i) -> System.out.println(i));

```

- 元素被访问的顺序取决于集合类型。如果ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而，如果访问HashSet中的元素，每个元素将会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预报元素被访问的次序。


- java集合类库中的迭代器与其他类库的迭代器在概念上有着重要区别。java的迭代器查找操作与位置变更是紧密相连的。查找一个元素的唯一方法是调用next。查找时迭代器位置随之移动。

- 因此，应该将java迭代器认为是位于两个元素之间。当调用next时，迭代器越过下一个元素，并返回刚刚越过的那个元素的引用。

- Iterator的remove方法将会删除上次调用next方法时返回的元素。
- 在C#中实现IEnumerator很方便，因为有yield关键字。但是java中就比较麻烦，可以模仿C#的编译器实现，使用内部类创建。
  
- 如果在remove之前没有调用next是不合法的。如果这样做，将会抛出一个IllegalStateException异常。

### 泛型实用方法

- 由于Collection和Iterator都是泛型接口，可以编写操作任何集合类型的使用方法。例如：下面是一个检测任意集合是否包含指定元素的泛型方法：
```
public static <E> boolean contains(Collection<E> c, Object obj){
    for(E element: C){
        if(element.equals(obj)){
            return true;
        }
    }
    return false;
}
```
- 在C#中，contains方法不是静态方法，List中使用的是Array.IndexOf方法判断。

- java类库的设计者认为：这些实用方法非常有用，应该将他们提供给用户使用。这样，使用者就不必子集重新构建方法了。
- Collection接口声明了很多有用的方法，所有的实现类都必须提供这些方法，下面是一部分例子：
```
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object other)
.... P367
```
- 类库提供了一个类AbstractCollection，他将基础方法size和iterator抽象化了，但是提供了其他方法的实例版本。所以我们可以通过继承该类免去编写一些例行方法。

- 创建一个Iterator比较麻烦，下面是模仿C#使用内部类实现的方法：
```
class StudentCollection extends AbstractCollection<Student> implements Collection<Student>{
    private Student[] students;
    private int capacity;
    private int num;
    public StudentCollection(){
        capacity = 100;
        num = 0;
        students = new Student[capacity];
    }

    @Override
    public Iterator<Student> iterator() {
        return new StudentIterator();
    }

    @Override
    public int size() {
        return num;
    }
    private class StudentIterator implements Iterator<Student>{
        private int currentNum;
        private Student current;
        public StudentIterator(){
            currentNum = -1;
            current = null;
        }
        @Override
        public boolean hasNext() {
           return StudentCollection.this.size() > currentNum+1;

        }

        @Override
        public Student next() {
            currentNum++;
            return StudentCollection.this.students[currentNum];
        }
    }
}
```

### 集合框架中的接口
- java集合框架为不同类型的集合定义了大量接口。

- 集合有两个基本接口：Collection和Map。Map是键值对。
- 以下是他们的不同：
```
作用    Map                     Collection
插入    put(k key, V value)     add(E element)
读取    get(K key)              迭代器
```

- List是一个有序集合。元素会增加到容器中的特定位置。可以采用两种方式访问元素：迭代器、整数索引。后一种方法称为随机访问，因为这样可以按任意顺序访问元素。

- 集合框架的这个方面设计的很不好。实际有两种有序集合，性能开销有很大差异。由数组支持的有序集合可以快速地随机访问，因此适合使用List方法并提供一个整数索引来访问。与之不同，链表尽管也是有序的，但是随机访问很慢，最好使用迭代器来遍历。但是这两个都实现的是List接口。如果原先提供两个接口就会好一点。

- 标记接口RandomAccess可以用来测试一个特定的集合是否支持高效的随机访问。

- Set接口等同于Collection接口，不过其方法有更严谨的定义。Set(集)接口不允许增加重复的元素。要是是当地定义集的equals方法：只要两个集包含同样的元素就认为是相等的，而不要求这些元素有同样的顺序。hashCode方法的定义要保证包含相同元素的两个集会得到想相同的散列码。

- SortedSet和SortedMap接口提供用于排序的比较器对象，这两个接口定义了可以得到集合子集视图的方法。

- java 6中定义了接口NavigableSet和NavigableMap，其中包含一些用于搜索和便利有序集和映射的方法。(本来应该直接包含在SortedSet和SortedMap接口中的)。TreeSet和TreeMap实现了这些接口。

--- 
## 具体的集合
- P380页展示了Java类库的具体集合。
    - ArrayList 动态增长和缩减的索引序列
    - LinkedList 一种可以在任何位置进行高效地插入和删除的有序序列
    - ArrayDeque 循环数组实现的双端队列
    - HashSet 没有重复元素的无序集合
    - TreeSet 有序集
    - EnumSet 包含枚举类型值的集
    - LinkedHashSet 记住元素插入次序的集
    - PriorityQueue 允许高效删除最小元素的集合
    - HashMap 存储键值对的数据结构
    - TreeMap 键值有序排列的映射表
    - EnumMap 键值属于枚举类型的映射表
    - LinkedHashMap 记住键值添加次序的映射表
    - WeakHashMap 值没用后可以被GC收回的映射表
    - IdentityHashMap 用==而不是Equals比较键值的映射表
  
### 链表
- 数据结构中的链表。java中的链表是双向链表。LinkedList

- 由于常常需要将元素添加到链表的中间，因此JAVA添加了一个新的接口ListIterator，包含add方法。
```
interface ListIterator<E> extends Iterator<E>
{
    void add(E element);
}
```
- 另外，ListIterator接口有两个方法，可以用来反向遍历链表。
```
E previous();
boolean hasPrevious()
```

- LinkedList的listIterator方法返回一个实现了ListTrerator接口的迭代器对象。

- add方法在迭代器位置之前添加一个新对象。

- remove方法则依赖于迭代器的当前状态。查看remove的源码：
```
public void remove() {
    if (lastRet < 0)
        throw new IllegalStateException();
    checkForComodification();

    try {
        AbstractList.this.remove(lastRet);
        if (lastRet < cursor)
            cursor--;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException e) {
        throw new ConcurrentModificationException();
    }
}
```
- 可以看到每次删除的时候会把lastRet置为-1，而lastRet小于0则不能remove，因此无法连续调用两次remove。
- lastRet是上一刻光标所在的位置，如ABCD，假设光标当前位置是C，previous的话光标会停在B，而lastRet指向C，即这时候remove会删除C。


- set方法用一个新元素取代调用next或previous方法返回的上一个元素。和remove一样，也是操作lastRet。

- 可以想象，如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，那这个迭代器就是无效的，并且不应该在使用。链表迭代器的设计使它能够检测到这种修改，而且会抛出一个异常。

- 为了避免发生并发修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。

- 一个简单的检测并发修改的方式是集合跟踪改写操作的次数。同时每个迭代器维护一个独立的计数值，当检测到计数值和集合的改写操作计数值不一致时，抛出异常。

- 列表迭代器有两个返回索引的方法。nextIndex返回下一次调用next时返回元素的整数索引。previousIndex返回洗一次调用previous时返回元素的整数索引。

### 数组列表
- ArrayList实现了List接口。ArrayList封装了一个动态再分配的对象数组。

- Vector类也是一个数组列表，但是Vector的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象。但是，如果只有一个线程，代码在同步操作上就要耗费大量的时间。而ArrayList的方法不是同步的，因此不需要同步时使用ArrayList。

### 散列集
- java中，散列表用链表数组实现。每个列表被称为桶(bucket)。这是一种解决散列冲突的方法。详细可以看数据结构。
- 在java 8中，桶满时会从链表变成平衡二叉树。这样可以提高性能

- 如果想更多地控制散列表的运行性能，可以指定一个初始的桶数。桶数最好是素数。(还有再散列，装填因子等概念，在数据结构中有，这里不再复述)。