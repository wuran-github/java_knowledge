# 并发
<!-- TOC -->

- [并发](#并发)
    - [什么是线程](#什么是线程)
        - [使用线程给其他任务提供机会](#使用线程给其他任务提供机会)
    - [中断线程](#中断线程)
    - [线程状态](#线程状态)
        - [新创建线程](#新创建线程)
        - [可运行线程](#可运行线程)
        - [被阻塞线程和等待线程](#被阻塞线程和等待线程)
        - [被终止线程](#被终止线程)
    - [线程属性](#线程属性)
        - [线程优先级](#线程优先级)
        - [守护线程](#守护线程)
        - [未捕获异常处理器](#未捕获异常处理器)
    - [同步](#同步)
        - [竞争条件的一个例子](#竞争条件的一个例子)
        - [竞争条件详解](#竞争条件详解)
        - [锁对象](#锁对象)
        - [条件对象](#条件对象)
        - [synchronized关键字](#synchronized关键字)
        - [同步阻塞](#同步阻塞)

<!-- /TOC -->

- 并发执行的进程数目并不是由CPU数目制约的。操作系统将CPU的时间片分配给每一个进程，给人并行处理的感觉。

- 多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程(thread)，它是线程控制的简称。
- 可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。

- 进程和线程的本质区别主要在于每个进程拥有子集的一整套变量，而线程则共享数据。

---
## 什么是线程
- 假设程序是一个单线程程序，如从1加到1000，每一秒加一次，界面上有一个cancel按钮，但是当程序开始执行时，除非执行完毕，你没有办法停止他，也就是加法结束之前无法与程序进行交互。

- 调用Thread.sleep不会创建一个新线程，sleep是Thread类的静态方法，用于暂停当前线程的活动。
- sleep方法可以抛出一个InterruptedException异常。

- 显然这是不合理的。人们希望能够通过某种方法停止当前执行的操作。

### 使用线程给其他任务提供机会
- 可以将加法放置在一个独立的线程中。实际上，可以把多个运算都放在自己的线程中运行。

- 下面是在一个单独的线程中执行一个任务的简单过程：
    1. 将任务代码移到实现了Runnable接口的类的run方法中。这个接口非常简单，只有一个run方法。
        - 由于Runnable是一个函数式接口，可以用lambda表达式创建一个实例：
        ```
        Runnable r = () -> {}
        ```   
    2. 由Runnable创建一个Thread对象：
    ```
    Thread t = new Thread(r);
    ```
    3. 启动线程：
    ```
    t.start();
    ``` 

- 也可以通过构建一个Thread类的子类定义一个线程。
- 不过这种方法已不在推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题。

---
## 中断线程
- 当线程的run方法执行完毕或出现了没有捕获的异常时，线程将中止。在早期版本中有stop方法可以终止线程。但是这个方法已经被弃用了。

- 没有可以`强制`线程终止的方法。然而，interrupt方法可以用来请求终止线程。

- 当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。
    - 注意，是需要程序手动去判断。

- 要弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法：
```
While(!Thread.currentThread().isInterrupted()){

}
```

- 但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个阻塞的线程(调用sleep或wait)上调用interrupt时，阻塞调用将会被InterrupedException异常中断。
- 存在不能被中断的阻塞I/O调用，应该考虑选择可中断的调用。

- 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。
- 某些线程时如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将终端作为一个终止的请求。这种线程的run方法具有如下形式：
```
Runnable r = () -> {
    try{
        while(!Thread.currentThread().isInterrupted())
    }catch(InterruptedException e){

    }finally{
        clean up
    }
};
```

- 如果在每次工作迭代之后都调用sleep方法(或其他可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法，它不会休眠。相反，他将清除这一状态并抛出InterruptedException。因此，如果你的循环调用sleep，不会检测中断状态。
```
Runnable r = () ->{
        try {
            int result = 0;
            for (int i = 0; i < 1000; i++) {
                result += i;
                Thread.sleep(1000);
                System.out.println(result);
            }
        }catch (InterruptedException ex){
            System.out.println("thread is already stop");
        }
        finally {
        }
    };
```

- 在很多发布的代码中会发现InterruptedException异常被抑制在很低的层次上：
```
void mySubTask(){
    try{
        sleep(delay);
    }catch(Interrupted e){ }
}
```
- 不要这样做。如果不想在catch中处理，还有两种选择：
    - 在catch子句中调用Thread.currentThread().interrupt()来设置中断状态。于是，调用者可以对其进行检测。
    ```
    public void run() {
        myTask();
        if(Thread.currentThread().isInterrupted()){
            System.out.println("capture interrupt success");
        }
    }
    private void myTask(){
        try {
            int result = 0;
            for (int i = 0; i < 1000; i++) {
                result += i;
                Thread.sleep(1000);
                System.out.println(result);
            }
        }catch (InterruptedException ex){
            Thread.currentThread().interrupt();
        }
    }
    ```

    - 或者，更好的选择时，用throws InterruptedException标记你的方法，不采用try语句块捕获异常。于是，调用者可以捕获这一异常。
    ```
    private void myTask2() throws InterruptedException {
        int result = 0;
        for (int i = 0; i < 1000; i++) {
            result += i;
            Thread.sleep(1000);
            System.out.println(result);
        }
    }
    private void runTaskTwo()  {
        try {
            myTask2();
        } catch (InterruptedException e) {
            System.out.println("capture interruptedException success");
        }
    }
    ``` 

---
## 线程状态
- 线程可以有如下5种状态:
    - New
    - Runnable
    - Blocked
    - Waiting
    - Timed waiting(计时等待)
    - Terminated(被终止)
- 要确定一个线程的当前状态，可调用getState方法。

### 新创建线程
- 当用new操作符创建一个新线程时，该线程还没有开始运行。此时它的状态是New。当一个线程处于NEW时，程序还没有开始运行线程中的代码。在运行前还有一些基础工作要做。
```
Thread t = new Thread(r);
System.out.println(t.getState());
//
NEW
```

### 可运行线程
- 一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行，也可能没有运行，这取决于操作系统给线程提供运行的时间。(java的规范说明没有将它作为一个单独状态。一个正在运行的线程仍然处于可运行状态。)

- 一旦一个线程开始运行，他不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节由操作系统提供。一般分为抢占式调度和协作式调度。
- 基本所有的桌面及服务器OS都使用抢占式调度，但是像手机这样的小型设备可能使用协作式调度。

- 在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当线程数量大于处理器时，调度依然采取时间片机制。

- 记住，在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。
```
t.start();
System.out.println(t.getState());
//
RUNNABLE
```


### 被阻塞线程和等待线程
- 当线程处于被阻塞或等待状态时，他暂时不活动。他不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

    - 当一个线程视图获取一个内部的对象锁，而该锁被其他线程持有，则线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它时，该线程将变成非阻塞状态。
     
    - 当线程通知另一个线程通知调度器一个条件时，他自己进入等待状态。后面讨论条件。在调用Object.wait方法或Thread.join方法，或是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态和等待状态有很大不同。

    - 有几个方法有一个超时参数。调用他们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或接收到适当的通知。如Thread.sleep Object.wait Thread.join Lock.tryLock Condition.await等。

### 被终止线程
- 线程因如下两个原因之一而被终止：
    - 因为run方法正常退出而自然死亡
    - 因为一个没有捕获的异常终止了run方法而意外死亡

- 特别是，可以调用线程的stop方法杀死一个线程。该方法抛出ThreadDeath错误对象，由此杀死线程。但是，stop方法已过时，不要使用。

---
## 线程属性

- 线程的属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。

### 线程优先级
- java中，每个线程都有优先级。默认情况下，线程继承父线程的优先级。可以用setPriority方法提高或降低线程的优先级。
- 可以将优先级设置为在MIN_PRIORITY(Thread中为1)与MAX_PRIORITY(10)之间的任何值。NORM_PRIORITY为5.

- 每当线程调度器有机会选择新的线程时，他首先选择具有较高优先级的线程。
- 但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时，java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。
- 如，windows有7个优先级。在Oracle为Linux提供的java虚拟机中，优先级被忽略。

- 初级程序员常常过度使用线程优先级。不要将程序构建为功能的正确性依赖于优先级。
- 高优先级没有进入非活动状态，低优先级的线程可能永远也不能执行。

### 守护线程
- 可以通过调用
```
t.setDaemon(true);
```
- 将线程转换为守护线程(daemon thread)。这样一个线程没有什么神奇。守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送"计时器滴答"信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时，虚拟机就退出了。
- 守护线程应该永远不去访问固有资源。

- 下面是一个例子，父线程执行完后会自动停止守护线程，尽管守护线程中没有退出代码。
```
class DaemonSimple implements Runnable{
    private ChildDaemon daemon = null;
    private Thread daemonThread = null;
    @Override
    public void run() {
        try {
            task();
        } catch (InterruptedException e) {
            System.out.println("interrupted");
        }
    }
    private void task() throws InterruptedException {
        startDaemon();
        int i = 1;
        while(true) {
            Thread.sleep(1000);
            System.out.println("task already run " + i);
            i++;
            if (daemon.times > 10) {
                System.out.println("times is ten. thread stop.");
                break;
            }
        }
    }
    private void startDaemon(){
        daemon = new ChildDaemon();
        Thread t = new Thread(daemon);
        t.setDaemon(true);
        t.start();
        daemonThread = t;
    }
    private class ChildDaemon implements Runnable{
        public int times = 0;
        @Override
        public void run() {
            try {
                task();
            } catch (InterruptedException e) {
                System.out.println("daemon thread was interrupted");
            }
        }
        private void task() throws InterruptedException {
            while(true) {
                Thread.sleep(1000);
                times++;
            }
        }
    }
}
```

### 未捕获异常处理器
- 线程的run方法不能抛出任何受查异常，但是，非受查会导致线程终止。

- 但是，不需要任何catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

- 该处理器必须属于一个实现ThreadExceptionHandler接口的类。这个接口只有一个方法：
```
void uncaughtException(Thread t, Throwable e)
```
- 可以用setUncaughtExceptionHandler方法为任何线程安装一个处理器。也可以用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。

- 如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。

- 线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组，但是，也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，建议不要在自己的程序中使用线程组。

- ThreadGroup类实现了上面说的接口，它的方法做如下操作：
    - 如果该线程组有父下次你哼组，那么调用父线程组的uncaughtException
    - 否则，如果Thread.getDefaultExceptionHandler返回非空的处理器，调用该处理器
    - 否则，如果Throwable是ThradDeath的一个实例，什么都不做。
    - 否则，线程的名字以及Throwable的栈轨迹被输出到System.err上。

- 下面是一个处理器的例子：

```
private static void captureThreadUnchekedExceptionTest(){
    Runnable r = new CaptureExceptionDemo();
    Thread t= new Thread(r);
    t.setUncaughtExceptionHandler(new Captor());
    t.start();
}

class Captor implements Thread.UncaughtExceptionHandler{

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println(e.getMessage());
        System.out.println("capture Exception success ");
    }
}
class CaptureExceptionDemo implements Runnable{
    @Override
    public void run() {
        int[] t = new int[1];
        t[1] = 0;
    }
}
```

---
## 同步

- 在大多数应用中，两个或以上线程同时访问一个数据是很正常的。如果同时修改一个数据就会造成问题。这个情况通常称为竞争条件(race condition)。

### 竞争条件的一个例子
- 为了避免这个问题，必须学习如何同步存取。本节介绍没有同步会发生什么。

- 在下面的测试程序中，模拟一个有若干账户的银行。每个账户有一个线程，程序会随机从一个账户转移一定的数目到另一个账户。
```
private static void normalTest(){
    Bank bank = new Bank();
    Runnable r =() ->{
        while (true) {
            Random fromRandom = new Random();
            Random toRandom = new Random();
            int amount = fromRandom.nextInt(50);
            int to = toRandom.nextInt(5);
            int from = fromRandom.nextInt(5);
            if(to == from){
                to = (to+1)%5;
            }
            bank.transfer(from,to, amount);
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    };
    Thread t1 = new Thread(r);
    Thread t2 = new Thread(r);
    Thread t3 = new Thread(r);
    t1.start();
    t2.start();
    t3.start();
}
class Bank {
    List<Account> accounts;
    public Bank(){
        accounts = new ArrayList<>();
        init();
    }
    private void init(){
        for (int i = 0; i < 5; i++) {
            Account account = new Account(i,1000);
            accounts.add(account);
        }
    }
    public void transfer(int from, int to, int amount){
        int fromBalance = accounts.get(from).getBalance();
        int toBalance = accounts.get(to).getBalance();
        fromBalance -= amount;
        toBalance += amount;
        accounts.get(from).setBalance(fromBalance);
        accounts.get(to).setBalance(toBalance);
        System.out.println(String.format("%d to %d , amount: %d totalBalance: %d ",from,to,amount,getTotalBalance()));

    }

    public int getTotalBalance(){
        int balance = 0;
        for (int i = 0; i < size(); i++) {
            balance += accounts.get(i).getBalance();
        }
        return balance;
    }
    public int size(){
        return accounts.size();
    }
}
//
2 to 3 , amount: 17 totalBalance: 5046 
0 to 1 , amount: 13 totalBalance: 5046 
1 to 0 , amount: 8 totalBalance: 5071 
0 to 1 , amount: 17 totalBalance: 5071 
3 to 4 , amount: 7 totalBalance: 5071 
1 to 2 , amount: 27 totalBalance: 5098 
3 to 1 , amount: 35 totalBalance: 5098
```

- 可以发现，在运行过程中总的余额发生了变化。这明显是一个严重的问题。

### 竞争条件详解

- 问题在于，假定两个线程同时执行指令：
```
accounts[to] += amount;
```
- 问题在于这不是原子操作。该指令可能被处理如下：
    1. 将`accounts[to]` 加载到寄存器
    2. 增加amount
    3. 将结果写回`accounts[to]`

- 现在，假定第一个线程执行了1和2，然后被剥夺了运行权。假定第2个线程被唤醒并修改了accounts数组中的同一项。然后，第一个线程被唤醒完成第3步。
- 这样，这一动作擦去了第二个线程所作的更新。于是，总金额就不再正确。

- 真正的问题是transfer方法再执行过程中可能被中断。

### 锁对象
- 有两种机制防止代码块受并发访问的干扰。java提供一个synchronized关键字达到这一目的，并且JAVA5引入了ReentrantLock类。
- synchronized自动提供一个锁以及相关的条件。

- 用ReentrantLock保护代码块的基本结构如下：
```
myLock.lock();//a ReentrantLock object
try{

}
finally{
    myLock.unlock();
}
```

- 这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，他们被阻塞，直到第一个线程释放锁对象。
- 因此，解锁方法放在finally中十分重要。确保一定会被解锁。

- 如果使用锁，就不能使用带资源的try语句。

- 用锁保护Bank的transfer方法如下：
```
private Lock lock;
public Bank(){
    accounts = new ArrayList<>();
    lock = new ReentrantLock();
    init();
}
public void transfer(int from, int to, int amount){
    lock.lock();
    try {
        int fromBalance = accounts.get(from).getBalance();
        int toBalance = accounts.get(to).getBalance();
        fromBalance -= amount;
        toBalance += amount;
        accounts.get(from).setBalance(fromBalance);
        accounts.get(to).setBalance(toBalance);
        System.out.println(String.format("%d to %d , amount: %d totalBalance: %d ", from, to, amount, getTotalBalance()));
    }
    finally {
        lock.unlock();
    }
}
```

- 假定一个线程调用transfer，在执行结束前被剥夺了运行权。第二个线程调用transfer时不能获得锁，将在调用lock方法时被阻塞。必须等到第一个线程unlock才能再度被激活。

- 注意每一个Bank对象有自己的ReentrantLock对象。如果两个线程试图访问同一个Bank对象，那么锁以串行方式提供服务。如果两个线程访问不同的Bank对象，每一个线程得到不同的锁对象，两个线程都不会发生阻塞。

- 锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。

- 例如，transfer方法调用getTotalBalance方法，这也会封锁bankLock对象，此时lock对象的持有计数为2.当getTotalBalance退出时，持有计数为1。当transfer退出，持有计数为0。线程释放锁。

- 要小心临界区的代码，不要因为异常的抛出而跳出临界区。如果再临界区代码结束之前抛出了异常，finally子句将释放锁，但会使对象可能处于一种受损状态。

- ReentrantLock有一个bool参数的构造函数。传入true构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一保证会大大降低性能。

### 条件对象
- 通常，线程进入临界区，却发现在某一条件满足之后他才能执行。要使用一个条件对象来管理那些已经获得了一个锁但却不能作有用工作的线程。

- 现在来细化银行的模拟程序。我们避免选择没有足够资金的账户作为转出账户。注意不能使用如下代码：
```
if(bank.getBalance(from) >= amount)
{
    ban.transfer(from, to, amount);
}
```
- 当前线程完全有可能在成功测试后，在调用transfer方法前被中断。

- 必须确保没有其他线程在本检查余额与转账活动之间修改余额。通过使用锁来保护检测与转账动作来到这一点：(也就是原子性)
```
public void transfer(int from, int to, int amount){
        lock.lock();
        try {
            int fromBalance =getBalance(from);
            if(fromBalance >= amount) {
                ...
            }
            else{
                System.out.println("has not enough balance");
            }
        }
        finally {
            lock.unlock();
        }
    }
```
- 现在，我们改变以下，当没钱时不是直接结束，而是等待直到另一个线程向账户中注入了资金。但是，这样线程刚刚获得了对bankLock的排他性访问，因此别的线程没有进行存款操作的机会。
- 这时候我们就需要条件对象。

- 一个锁对象可以有一个或多个相关的条件对象。你可以使用newCondition方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。例如，在此设置一个条件对象表达余额充足条件。

- 如果transfer方法发现余额不足，他调用：
```
sufficientFunds.await();
```
- 当前线程被阻塞了，并放弃了锁。我们希望这样可以是的另一个线程可以进行增加账户余额的操作。

- 等待获得锁的线程和调用await方法的线程存在本质上的不同。
- 一旦一个线程调用await方法，他进入该条件的等待集。当锁可用时，该线程不能马上结束阻塞。相反，它处于阻塞状态，直到另一个线程调用同意条件上的signalAll方法为止。

- 当另一个线程转账时，它应该调用
```
sufficientFunds.signalAll();
```
- 这一调用重新激活因为这一条件而等待的所有线程。当这些线程从等待集当中移出时，它们再次成为可运行的，调度器将再次激活它们。同时，他们将试图重新进入该对象。一旦锁成为可用的，他们中的某个将从await调用返回，获得该锁并从被阻塞的地方继续执行。

- 此时，线程应该再次测试该条件。
- 通常对await的调用在如下形式的循环体中：
```
while(!(ok to proceed)){
    condition.await();
}
```

- 至关重要的是需要某个线程调用signalAll方法。当线程调用await后，他没办法重新激活自身，只能寄望于其他线程。如果没有线程调用该方法，就会导致死锁现象。

- 经验上讲，在对象的状态有利于等待线程的方向改变时调用signalAll。
```
public void transfer(int from, int to, int amount) {
    lock.lock();
    try {
        int fromBalance = getBalance(from);
        while (fromBalance < amount) {
            sufficientFunds.await();
        }
        int toBalance = accounts.get(to).getBalance();
        fromBalance -= amount;
        toBalance += amount;
        accounts.get(from).setBalance(fromBalance);
        accounts.get(to).setBalance(toBalance);
        System.out.println(String.format("%d to %d , amount: %d totalBalance: %d ", from, to, amount, getTotalBalance()));
        sufficientFunds.signalAll();
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}
//观察程序，会发现执行一段时间后就卡死了。这时候就是因为进入了死锁状态
//所以有时候放弃操作是更好的选择
```

- 注意调用signalAll不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法后，通过竞争实现对对象的访问。

- signal方法随机解除等待集中某个线程的阻塞状态，


### synchronized关键字
- 大多数情况下，不需要Lock和Condition这种级别的控制。可以使用一种嵌入到java语言内部的机制。
- 从1.0开始，java中的每一个对象都有一个内部锁。
- 如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。换句话说：
```
public synchronized void method(){

}
```
- 等价于
```
public void method(){
    this.intrinsicLock.lock();
    try{
        
    }finally{
        this.intrinsicLock.unlock();    
    }
}
```

- 例如，可以简单地证明Bank类的transfer方法为synchronized，而不是使用一个显式的锁。
```
public synchronized void transfer(int from, int to, int amount) {
    try {
        int fromBalance = getBalance(from);
        while (fromBalance < amount) {
            wait();
        }
        int toBalance = accounts.get(to).getBalance();
        fromBalance -= amount;
        toBalance += amount;
        accounts.get(from).setBalance(fromBalance);
        accounts.get(to).setBalance(toBalance);
        System.out.println(String.format("%d to %d , amount: %d totalBalance: %d ", from, to, amount, getTotalBalance()));
        notifyAll();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

- 内部对象锁只有一个相关条件。wait方法添加一个线程到等待集，notifyAll和notify解除等待线程的阻塞状态。

- wait notifyAll和notify是Object的final方法。

- 将静态方法声明为synchronized也是合法的。如果调用这个方法，该方法获得相关的类对象的内部锁。例如，如果Bank类雨哦一个静态同步的方法，那么当该方法被调用时，Bank.class对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。

- 内部锁和条件存在一些局限。包括：
    - 不能中断一个正在试图获得锁的线程。
    - 试图获得锁时不能设定超时。
    - 每个锁仅有单一的条件，可能是不够的。


- 对于这两种方法：
- 最好既不使用Lock/Condition也不适用synchronized关键字。许多情况下可以使用java.util.concurrent包中的机制，他会为你处理所有的加锁。
- 如果synchronized适合你的冠城，请尽量使用它，这样可以减少编写的代码数量，减少出错的机率。
- 如果特别需要Lock/Condition结构提供的独有特性时，才使用它。

### 同步阻塞
- P673