# 并发
<!-- TOC -->

- [并发](#并发)
    - [什么是线程](#什么是线程)
        - [使用线程给其他任务提供机会](#使用线程给其他任务提供机会)
    - [中断线程](#中断线程)
    - [线程状态](#线程状态)
        - [新创建线程](#新创建线程)
        - [可运行线程](#可运行线程)
        - [被阻塞线程和等待线程](#被阻塞线程和等待线程)
        - [被终止线程](#被终止线程)
    - [线程属性](#线程属性)
        - [线程优先级](#线程优先级)
        - [守护线程](#守护线程)
        - [未捕获异常处理器](#未捕获异常处理器)
    - [同步](#同步)
        - [竞争条件的一个例子](#竞争条件的一个例子)

<!-- /TOC -->

- 并发执行的进程数目并不是由CPU数目制约的。操作系统将CPU的时间片分配给每一个进程，给人并行处理的感觉。

- 多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务称为一个线程(thread)，它是线程控制的简称。
- 可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。

- 进程和线程的本质区别主要在于每个进程拥有子集的一整套变量，而线程则共享数据。

---
## 什么是线程
- 假设程序是一个单线程程序，如从1加到1000，每一秒加一次，界面上有一个cancel按钮，但是当程序开始执行时，除非执行完毕，你没有办法停止他，也就是加法结束之前无法与程序进行交互。

- 调用Thread.sleep不会创建一个新线程，sleep是Thread类的静态方法，用于暂停当前线程的活动。
- sleep方法可以抛出一个InterruptedException异常。

- 显然这是不合理的。人们希望能够通过某种方法停止当前执行的操作。

### 使用线程给其他任务提供机会
- 可以将加法放置在一个独立的线程中。实际上，可以把多个运算都放在自己的线程中运行。

- 下面是在一个单独的线程中执行一个任务的简单过程：
    1. 将任务代码移到实现了Runnable接口的类的run方法中。这个接口非常简单，只有一个run方法。
        - 由于Runnable是一个函数式接口，可以用lambda表达式创建一个实例：
        ```
        Runnable r = () -> {}
        ```   
    2. 由Runnable创建一个Thread对象：
    ```
    Thread t = new Thread(r);
    ```
    3. 启动线程：
    ```
    t.start();
    ``` 

- 也可以通过构建一个Thread类的子类定义一个线程。
- 不过这种方法已不在推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用线程池来解决这个问题。

---
## 中断线程
- 当线程的run方法执行完毕或出现了没有捕获的异常时，线程将中止。在早期版本中有stop方法可以终止线程。但是这个方法已经被弃用了。

- 没有可以`强制`线程终止的方法。然而，interrupt方法可以用来请求终止线程。

- 当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。
    - 注意，是需要程序手动去判断。

- 要弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted方法：
```
While(!Thread.currentThread().isInterrupted()){

}
```

- 但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个阻塞的线程(调用sleep或wait)上调用interrupt时，阻塞调用将会被InterrupedException异常中断。
- 存在不能被中断的阻塞I/O调用，应该考虑选择可中断的调用。

- 没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。
- 某些线程时如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将终端作为一个终止的请求。这种线程的run方法具有如下形式：
```
Runnable r = () -> {
    try{
        while(!Thread.currentThread().isInterrupted())
    }catch(InterruptedException e){

    }finally{
        clean up
    }
};
```

- 如果在每次工作迭代之后都调用sleep方法(或其他可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法，它不会休眠。相反，他将清除这一状态并抛出InterruptedException。因此，如果你的循环调用sleep，不会检测中断状态。
```
Runnable r = () ->{
        try {
            int result = 0;
            for (int i = 0; i < 1000; i++) {
                result += i;
                Thread.sleep(1000);
                System.out.println(result);
            }
        }catch (InterruptedException ex){
            System.out.println("thread is already stop");
        }
        finally {
        }
    };
```

- 在很多发布的代码中会发现InterruptedException异常被抑制在很低的层次上：
```
void mySubTask(){
    try{
        sleep(delay);
    }catch(Interrupted e){ }
}
```
- 不要这样做。如果不想在catch中处理，还有两种选择：
    - 在catch子句中调用Thread.currentThread().interrupt()来设置中断状态。于是，调用者可以对其进行检测。
    ```
    public void run() {
        myTask();
        if(Thread.currentThread().isInterrupted()){
            System.out.println("capture interrupt success");
        }
    }
    private void myTask(){
        try {
            int result = 0;
            for (int i = 0; i < 1000; i++) {
                result += i;
                Thread.sleep(1000);
                System.out.println(result);
            }
        }catch (InterruptedException ex){
            Thread.currentThread().interrupt();
        }
    }
    ```

    - 或者，更好的选择时，用throws InterruptedException标记你的方法，不采用try语句块捕获异常。于是，调用者可以捕获这一异常。
    ```
    private void myTask2() throws InterruptedException {
        int result = 0;
        for (int i = 0; i < 1000; i++) {
            result += i;
            Thread.sleep(1000);
            System.out.println(result);
        }
    }
    private void runTaskTwo()  {
        try {
            myTask2();
        } catch (InterruptedException e) {
            System.out.println("capture interruptedException success");
        }
    }
    ``` 

---
## 线程状态
- 线程可以有如下5种状态:
    - New
    - Runnable
    - Blocked
    - Waiting
    - Timed waiting(计时等待)
    - Terminated(被终止)
- 要确定一个线程的当前状态，可调用getState方法。

### 新创建线程
- 当用new操作符创建一个新线程时，该线程还没有开始运行。此时它的状态是New。当一个线程处于NEW时，程序还没有开始运行线程中的代码。在运行前还有一些基础工作要做。
```
Thread t = new Thread(r);
System.out.println(t.getState());
//
NEW
```

### 可运行线程
- 一旦调用start方法，线程处于runnable状态。一个可运行的线程可能正在运行，也可能没有运行，这取决于操作系统给线程提供运行的时间。(java的规范说明没有将它作为一个单独状态。一个正在运行的线程仍然处于可运行状态。)

- 一旦一个线程开始运行，他不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节由操作系统提供。一般分为抢占式调度和协作式调度。
- 基本所有的桌面及服务器OS都使用抢占式调度，但是像手机这样的小型设备可能使用协作式调度。

- 在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当线程数量大于处理器时，调度依然采取时间片机制。

- 记住，在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。
```
t.start();
System.out.println(t.getState());
//
RUNNABLE
```


### 被阻塞线程和等待线程
- 当线程处于被阻塞或等待状态时，他暂时不活动。他不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

    - 当一个线程视图获取一个内部的对象锁，而该锁被其他线程持有，则线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它时，该线程将变成非阻塞状态。
     
    - 当线程通知另一个线程通知调度器一个条件时，他自己进入等待状态。后面讨论条件。在调用Object.wait方法或Thread.join方法，或是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。实际上，被阻塞状态和等待状态有很大不同。

    - 有几个方法有一个超时参数。调用他们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或接收到适当的通知。如Thread.sleep Object.wait Thread.join Lock.tryLock Condition.await等。

### 被终止线程
- 线程因如下两个原因之一而被终止：
    - 因为run方法正常退出而自然死亡
    - 因为一个没有捕获的异常终止了run方法而意外死亡

- 特别是，可以调用线程的stop方法杀死一个线程。该方法抛出ThreadDeath错误对象，由此杀死线程。但是，stop方法已过时，不要使用。

---
## 线程属性

- 线程的属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。

### 线程优先级
- java中，每个线程都有优先级。默认情况下，线程继承父线程的优先级。可以用setPriority方法提高或降低线程的优先级。
- 可以将优先级设置为在MIN_PRIORITY(Thread中为1)与MAX_PRIORITY(10)之间的任何值。NORM_PRIORITY为5.

- 每当线程调度器有机会选择新的线程时，他首先选择具有较高优先级的线程。
- 但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时，java线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。
- 如，windows有7个优先级。在Oracle为Linux提供的java虚拟机中，优先级被忽略。

- 初级程序员常常过度使用线程优先级。不要将程序构建为功能的正确性依赖于优先级。
- 高优先级没有进入非活动状态，低优先级的线程可能永远也不能执行。

### 守护线程
- 可以通过调用
```
t.setDaemon(true);
```
- 将线程转换为守护线程(daemon thread)。这样一个线程没有什么神奇。守护线程的唯一用途是为其他线程提供服务。计时线程就是一个例子，它定时地发送"计时器滴答"信号给其他线程或清空过时的高速缓存项的线程。当只剩下守护线程时，虚拟机就退出了。
- 守护线程应该永远不去访问固有资源。

- 下面是一个例子，父线程执行完后会自动停止守护线程，尽管守护线程中没有退出代码。
```
class DaemonSimple implements Runnable{
    private ChildDaemon daemon = null;
    private Thread daemonThread = null;
    @Override
    public void run() {
        try {
            task();
        } catch (InterruptedException e) {
            System.out.println("interrupted");
        }
    }
    private void task() throws InterruptedException {
        startDaemon();
        int i = 1;
        while(true) {
            Thread.sleep(1000);
            System.out.println("task already run " + i);
            i++;
            if (daemon.times > 10) {
                System.out.println("times is ten. thread stop.");
                break;
            }
        }
    }
    private void startDaemon(){
        daemon = new ChildDaemon();
        Thread t = new Thread(daemon);
        t.setDaemon(true);
        t.start();
        daemonThread = t;
    }
    private class ChildDaemon implements Runnable{
        public int times = 0;
        @Override
        public void run() {
            try {
                task();
            } catch (InterruptedException e) {
                System.out.println("daemon thread was interrupted");
            }
        }
        private void task() throws InterruptedException {
            while(true) {
                Thread.sleep(1000);
                times++;
            }
        }
    }
}
```

### 未捕获异常处理器
- 线程的run方法不能抛出任何受查异常，但是，非受查会导致线程终止。

- 但是，不需要任何catch子句来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

- 该处理器必须属于一个实现ThreadExceptionHandler接口的类。这个接口只有一个方法：
```
void uncaughtException(Thread t, Throwable e)
```
- 可以用setUncaughtExceptionHandler方法为任何线程安装一个处理器。也可以用Thread类的静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。

- 如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。

- 线程组是一个可以统一管理的线程集合。默认情况下，创建的所有线程属于相同的线程组，但是，也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，建议不要在自己的程序中使用线程组。

- ThreadGroup类实现了上面说的接口，它的方法做如下操作：
    - 如果该线程组有父下次你哼组，那么调用父线程组的uncaughtException
    - 否则，如果Thread.getDefaultExceptionHandler返回非空的处理器，调用该处理器
    - 否则，如果Throwable是ThradDeath的一个实例，什么都不做。
    - 否则，线程的名字以及Throwable的栈轨迹被输出到System.err上。

- 下面是一个处理器的例子：

```
private static void captureThreadUnchekedExceptionTest(){
    Runnable r = new CaptureExceptionDemo();
    Thread t= new Thread(r);
    t.setUncaughtExceptionHandler(new Captor());
    t.start();
}

class Captor implements Thread.UncaughtExceptionHandler{

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println(e.getMessage());
        System.out.println("capture Exception success ");
    }
}
class CaptureExceptionDemo implements Runnable{
    @Override
    public void run() {
        int[] t = new int[1];
        t[1] = 0;
    }
}
```

---
## 同步

- 在大多数应用中，两个或以上线程同时访问一个数据是很正常的。如果同时修改一个数据就会造成问题。这个情况通常称为竞争条件(race condition)。

### 竞争条件的一个例子
- 为了避免这个问题，必须学习如何同步存取。本节介绍没有同步会发生什么。

- 在下面的测试程序中，模拟一个有若干账户的银行。每个账户有一个线程，程序会随机从一个账户转移一定的数目到另一个账户。