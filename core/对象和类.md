# 对象和类

## 概述
- 传统结构化程序设计先考虑算法，后考虑数据结构。 算法 + 数据结构 = 程序
- 而在OOP(Object-Oriented Programming)中则调换了次序，将数据放到第一位，在考虑操作数据的算法。

### 类
- 类(class)时构造对象的模板或蓝图。由类构造(construct)对象的过程称为创建类的实例(instance)。
- 封装(encapsulation，有时称为数据隐藏)。从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。
    - 对象中的数据称为 `实例域`(instance field)。操纵数据的过程称为 `方法`(method)。
    - 对于每个特定的对象都有一组特定的实例域值。这些值的集合就是这个对象的当前状态(state)。

### 对象
- 对象的三个主要特性
    1. 对象的行为(behavior):可以对对象施加那些操作？
    2. 对象的状态(state)：施加方法时，对象如何响应？
    3. 对象标识(identity):如何辨别具有相同行为和状态的不同对象？

### 类之间的关系
- 常见关系
    - 依赖("uses-a")
        - 依赖(dependence)是最明显常见的关系。如Order使用Account类是因为Order对象需要访问Account对象查看信用状态。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。
    - 聚合("has-a")
        - 一个Order对象包含一些Item对象。聚合关系一额外着类A的对象包含B的对象。
    - 继承("is-a")

## 使用预定义类

### 对象和对象变量
- 使用对象必须先构造(construct)对象，并指定其初始状态。
- 在JAVA中，使用构造器(constructor)构造新实例。
- 构造器的名字与类名相同，在构造器前加上 `new`操作符构造对象。
```
Date date = new Date();
```
- 对象和对象变量之间存在着重要区别，变量可以引用对象。

### Java的LocalDate
- Date类表示时间使用一距离一个固定时间点的毫秒数来表示的，这个店就是所谓的纪元(epoch)，是UTC时间1970年1月1日00：00：00.
- LocalDate则是用来表示日历的，只保存了日期没有时间
```
LocalDate date = LocalDate.now();
```
- LocalDate不能用构造器来构造，要用静态工厂方法。
- 也可以提供年月日来构造
```
LocalDate date = LocalDate.of(1992,11,11);
```

### 更改器方法和访问器方法
- 修改了对象状态的方法称为更改器方法(mutator method)。也就是set方法
- 只访问对象而不修改对象的方法称为访问器方法(accessor method)，也就是get方法。

## 用户自定义类
- java中，文件名必须与public类的名字相匹配。
- 一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。

### 多个源文件的使用
- 假设有两个类
```
public class EmpolyeeTest
{
    public static void main(String[] args){
        Employee employee = new Employee();
        employee.print();
    }
}
class Employee{
    public Employee(){

    }
    public void print(){
        System.out.println("test");
    }
}
```
- 习惯来说每个类应该放在单独的源文件中。如Employee放在Employee.java,Test放在xxTest.java文件中。
- 这样组织文件有两种编译的方法。
    1. 使用通配符编译
    ```
    javac Employee*.java
    ```
    
    2. `javac EmployeeTest.java`

- 使用第二种方法并没有显式编译Employee.java。然而，当Java编译器发现Test.java使用了Employee类时会查找名为Employee.class的文件。如果没有找到，就会自动搜索Employee.java，然后，对他进行编译。
- 更重要的是，如果java文件比class文件版本新，编译器会自动重新编译该文件。
- 可以认为java编译器内置了`make` 功能。

### 剖析Empolyee类
- Employee包含一个构造器和4个方法。
- 所有方法都被标记为 `public` 。public 意味着任何类的任何方法都可以调用这些方法。
- private 确保只有Employee类自身的方法能够访问。

### 从构造器开始

- 构造器总是伴随着new 操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。
- 记住几点：
    - 构造器与类同名。
    - 每个类可以有一个以上的构造器。
    - 构造器可以有0或多个参数。
    - 构造器没有返回值。
    - 构造器总是伴随着new操作一起调用。

### 隐式参数和显式参数
```
public void raiseSalary(double salary){
    this.salary = salary;
}
```
- raiseSalary方法有两个参数。第一个参数称为隐式(implicit)参数，是出现在方法名前的Employee类对象。第二个参数位于方法名后面括号中的数字，这是一个显式(explicit)参数。（有些人把隐式参数称为方法调用的目标）。
- 可以看到，显式参数是明显地列在方法声明中的。隐式参数则没有。
- 在每一个方法中，关键字 `this`表示隐式参数。

### 封装的优点
```
public String getName(){
    return name;
}
```
- 这是典型的访问器方法。只返回实例域值，又称域访问器。
- 优点就是我们可以在访问器和更改器中加上其他语句，要修改也只需要在这一处修改。
- 注意，尽量不要编写返回引用可变对象的访问器方法。如果要返回，应该返回一个clone()对象。

### 基于类的访问权限
- 从前面知道，方法可以访问所调用对象的私有数据。
- 还有一点，一个方法可以访问所属类的 `所有对象` 的私有数据。看如下代码：
```
class Employee{
    public boolean equals(Employee other){
        return name.equals(other.name);
    }
}
if(harry.equals(boss))
```
- 这个方法访问了自己的私有域，这不奇怪，但是，他还访问了other的私有域。这是合法的，其原因是boss是Employee类对象，而Employee类的方法可以访问Employee类的任何一个对象的私有域。

- (在C#和C++中也是如此) ，方法可以访问所属类的私有特性(feature)，而不仅限于访问隐式参数的私有特性。

### 私有方法
- 实现一个私有方法，只需要使用private关键字。
- 对于私有方法，类的设计者可以确信：他不会被外部的其他类调用，可以将其删去。如果方法是公有的，则无法保证。

### final实例域
- 可以将实例域定义为final。构建对象时必须初始化这样的域。
- 必须确保在每一个构造器执行后，这个域的值被设置，并且以后不能再修改。
```
class Employee{
    private final String name;
}
```
- final修饰符大都应用于基本(primitive)或不可变(immutable)类型的域。

---
## 静态域和静态方法。

### 静态域
- 如果将域定义为static，则域属于类，而不是对象。
```
static int nextId = 1;
```

### 静态常量
- 静态变量用的较少，但是静态常量却经常使用。如
```
public class Math{
    public static final double PI = 3.14.....
}
```
- 可以通过Math.PI来访问。
- 公有常量(即final域)设置为public时没问题的，因为不会被改变。

p131