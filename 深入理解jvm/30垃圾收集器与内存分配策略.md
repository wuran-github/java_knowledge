# 垃圾收集器与内存分配策略

- 垃圾收集需要完成三件事情：
    - 哪些内存需要回收
    - 什么时候回收
    - 如何回收
<!-- TOC -->

- [垃圾收集器与内存分配策略](#垃圾收集器与内存分配策略)
    - [对象消亡](#对象消亡)
        - [引用计数算法](#引用计数算法)
        - [可达性分析算法](#可达性分析算法)
        - [再谈引用](#再谈引用)
        - [对象是否被清除](#对象是否被清除)
        - [回收方法区](#回收方法区)
    - [垃圾收集算法](#垃圾收集算法)
        - [分代收集理论](#分代收集理论)
        - [标记-清除算法](#标记-清除算法)
        - [标记-复制法](#标记-复制法)
        - [标记-整理法](#标记-整理法)
    - [经典垃圾收集器](#经典垃圾收集器)
        - [Serial收集器](#serial收集器)
        - [ParNew收集器](#parnew收集器)
        - [Parallel Scavenge收集器](#parallel-scavenge收集器)
        - [Serial Old收集器](#serial-old收集器)
        - [Parallel Old收集器](#parallel-old收集器)
        - [CMS收集器](#cms收集器)
        - [Garbage First（G1）收集器](#garbage-firstg1收集器)

<!-- /TOC -->
---
## 对象消亡
- 垃圾回收器在对堆进行回收前，第一件事就是确定这些对象中哪些已经消亡（不可能再被任何途径使用）。

### 引用计数算法
- 最简单的方法就是，在对象中添加一个引用计数器，每当被一个地方引用，计数器加一，引用失效，计数器减一。
- 计数器为0，说明对象消亡。

- 引用计数器算法(Reference Counting)十分简单，判定效率也很高。
- 但是这个方法有很多问题，例如：对象之间互相循环引用。
    - 假设A引用了B，B引用了A，那么这2个对象将永远不会消亡。

### 可达性分析算法
- 当前主流语言的内存管理子系统，都是通过可达性分析(Reachability Analysis)算法来判定对象是否存活的。

- 这个算法的基本思路是通过一系列称为 `GC Roots`的根对象作为起始节点集，从这些节点开始，根据引用关系乡下搜索，搜索过程锁走过的路径称为 `引用链`(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，则证明对象已消亡。（即图论中的不可达）。

- 在Java中，固定可作为GC Roots的对象包括以下几种：
    - 在虚拟机栈中引用的对象
    - 在方法区中类静态属性引用的对象，例如引用类型静态变量。
    - 在方法区中常量引用的对象，例如字符串常量池中的引用。
    - 在本地方法栈中本地方法引用的对象。
    - java虚拟机内部的引用。
    - 所有被同步锁持有的对象。
    - 反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等。

- 除了这些外，还会根据情况有其他对象临时性加入，共同构成GC Roots集合。  


### 再谈引用

### 对象是否被清除
- 即使在可达性分析算法中被判定为不可达的对象，也不是马上消亡，要真正消亡需要经历2次标记过程：
    - 如果对象在可达性分析后被发现不可达，进行第一次标记。
    - 随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()函数，加入对象没有覆盖finalize()方法，或者该方法已经被虚拟机调用过，那么这2种情况都视为没有必要执行。

- 如果对象被判定为有必要执行finalize()方法，那么该对象会被放置在一个名为F-Queue的队列中，并在稍后虚拟机会自动创建一个低调度优先级的Finalizer线程区执行它们的finalize()方法。
- finalize()方法不代表对象一定会消亡，他可能会在这个方法内重新被引用，重新可达，这时候就会被移出即将回收的集合。

- 另外这个方法最好不要使用。

### 回收方法区


----
## 垃圾收集算法

- 从如何判定对象消亡的角度，垃圾收集算法可以划分为 `引用计数式垃圾收集` 和 `追踪式垃圾收集`。 也称为 `直接垃圾收集`和`间接垃圾收集`。
- 下面提到的所有算法都属于追踪式垃圾收集。

### 分代收集理论
- 现代的垃圾收集大多遵守如下2个假说：
    - 弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。
    - 强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象越难消亡。

- 这2个假说奠定了大部分垃圾收集器的设计原则：
    - 收集器应将Java堆划分出不同的区域，然后将回收对象依据其年龄（即对象熬过垃圾收集过程的次数）分配到不同的区域之间存储。

- java堆划分出不同的区域后，垃圾收集器才可以每次只回收某一个或者某些部分的区域，因此才有：`Minor GC`，`Major GC`，`Full GC`这样的回收类型划分。

- 在现在的Java虚拟机里，一般会至少把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域。
- 新生代中，每次垃圾收集时都会有大批对象消亡，每次回收后存货的少量对象，会逐步晋升到老年代中存放。

- 但是分代收集并非只是划分一下内存区域这么简单，有一个明显的困难：对象不是孤立的，对象之间会存在跨代引用。

- 假如现在要进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象时完全有可能被老年代所引用的，因此我们不得不遍历老年代来进行可达性分析。
- 为此，我们需要添加第三条法则：
    - 跨代引用假说（Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数。

- 这其实是根据前2条假说推断出来的，因为存在跨代引用的对象会逐步晋升到老年代变成同代引用。

- 依据这条假说，我们只需在新生代上建立一个全局的数据结构（该结构被称为`记忆集`，Remembered Set)，这个结构把老年代划分为若干小块，标识出老年代的哪一块内存会存在跨代引用。
- 此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

- 一些名词：
    - 部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集，又分为：
        - 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集
        - 老年代收集(Major GC/Old GC):有时候Major GC这个说法会指整堆收集
        - 混合收集(Mixed GC):目标是整个新生代以及部分老年代的垃圾收集。只有G1收集器会有这种行为。
    - 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。

### 标记-清除算法
- 标记清除算法是最基础最早的，算法分为 `标记` 和 `清除`2个阶段：
    - 首先标记出要回收的对象，标记完成后，统一回收所有被标记的对象。
    - 也可以反过来，标记存活的对象，回收未被标记的对象。

- 缺点：
    - 执行效率不稳定，要做大量的标记和清除动作
    - 内存空间会碎片化

### 标记-复制法
- 或叫复制法。是为了解决标记-清除法效率低的问题。
- 将可用内存划分为大小相等的2块，每次只使用其中一块，当这一块内存用完了，就将还活着的对象复制到另一块上，直接清除当前这块。
- 如果存活对象很多，这个开销很大，但是根据分代理论的第一条假说，大部分对象都是朝生夕灭的，因此实际上复制开销不会很多。
- 缺点：
    - 空间浪费大。

- 实际上现在的虚拟机大多优先采用这种算法去回收新生代，不过划分比例并不是1：1。
- 有一种Appel式回收是把新生代划分为一块较大的Eden空间和2块较小的Survivor空间。每次分配内存只是用Eden和其中一块Survivor。垃圾回收时，把仍存活的对象复制到另一块Survivor上，清除使用的2块内存。
- 一般Eden和Survivor的默认比例是8:1，即每次只使用90%的内存空间，这样只浪费10%。


### 标记-整理法
- 上面说的复制法一般用于新生代。但是老年代的存活对象较多，不能使用复制法。
- 针对老年代，使用标记-整理法。
- 标记整理法和清除法类似，但是标记后不是清除对象，而是把存活对象往内存一端移动，然后清除掉边界以外的内存。

- 移动存活对象是一种极为负重的操作，这种操作必须全程跟暂停用户应用程序才能进行。这就是"Stop The World"。

---
## 经典垃圾收集器
- 目前常用的垃圾收集器分为新生代和老生代的，也有一个收集器同时用于2个内存区的，左边的是新生代，右边的是老生代的：
- Serial-CMS/Serial Old
- ParNew-CMS/Serial Old
- Parallel Scavenge-Serial Old/Parallel Old
- G1

### Serial收集器
- Serial是最基础，最悠久的收集器。这个收集器是单线程工作的，而且他在垃圾收集时必须暂停其他所有工作线程。
- 他的优点就是简单高效，消耗内存小。使用标记-复制算法。

### ParNew收集器
- ParNew可以看作是Serial的多线程并行版本。只是收集时使用多个线程，但是GC时还是要暂停其他工作线程。


### Parallel Scavenge收集器
- Parallel Scavenge收集器也是一款新生代收集器，也是基于标记-复制算法实现的。和ParNew很相似，也是多线程。
- 它的特点是关注点和其他收集器不同，Parallel Scavenge收集器的目标是达到一个可控的吞吐量。其他收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。
- 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
  

### Serial Old收集器
- 看名字就知道这个收集器就是Serial的老年代版本，使用标记-整理算法。

### Parallel Old收集器
- 是Parallel Scavenge的老年代版本，支持多线程并发收集。


### CMS收集器
- CMS收集器是一种以获取最短回收停顿时间为目标的收集器。
- CMS是基于标记-清除算法的，而不是标记-整理算法。运作过程如下：
    1. 初始标记
    2. 并发标记
    3. 重新标记
    4. 并发清除

- 其中1、3步依然需要Stop The World。
- 初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快。
- 并发标记是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长，但不需要停顿用户线程，可以和垃圾收集线程一起并发运行。
- 重新标记是为了修正并发标记期间，因用户程序继续运行而导致标记变动的那一部分对象的标记记录。需要STW。
- 并发清除，清理删除掉已经被标记死亡的对象，因为使用的是清除法，不需要移动存货对象，不需要STW。

- 三个缺点：
    - 对处理器资源非常敏感。可能会占用较多的处理器运算资源。
    - 无法处理`浮动垃圾`。在并发标记和并发清除阶段，由于没有STW，因此程序可能会产生新垃圾，这些就叫浮动垃圾。
    - 由于基于标记-清除算法，会导致内存碎片过多。

### Garbage First（G1）收集器
- G1收集器是里程碑式的成果，目的是替换掉之前的老的收集器。

- 以前的收集器都是的目标只有3块，要么是Full GC，要么是Minor GC，要么Major GC。而G1则是可以面对堆内存任何部分来组成回收集进行回收。称为 Mixed GC。

- G1是基于Region的，和其他回收器不一样：他把连续的Java堆划分为多个独立的大小相等的Region，每个Region可以根据需要，扮演Eden或者Survivor或者老年代空间。

- Region还有一类特殊的Humongous区域，用来存储大对象。大小超过了Region容量的一半即视为大对象。这部分区域大部分或被当作老年代的一部分来处理。

- G1会跟踪各个Region的垃圾堆的价值大小，即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，根据用户设定的收集停顿时间，优先处理回收价值收益最大的那些Region。

- 划分Region有很多问题要处理，G1至少要耗费大约相当于Java堆容量10%-20%的额外内存来维持收集器工作。

- 如果内存回收的速度赶不上内存分配的速度，G1收集器也只能使用Full GC而产生长时间的STW。

- G1的运行过程大致划分为如下4个步骤：
    1. 初始标记。 仅仅标记一下GC Roots能直接关联到的对象。这个阶段需要STW，但是很短。而且是借用Minor GC的时候同步完成的。
    2. 并发标记。 递归扫描整个对象图，进行可达性分析，找出要回收的对象。耗时长，但可并发，不需要STW。
    3. 最终标记：处理并发阶段结束后扔遗留下来的少量的SATB记录。需要STW。
    4. 筛选回收：更新Region的统计数据，对Region的回收价值和成本进行排序，根据设定的停顿时间来制定回收计划。需要STW。